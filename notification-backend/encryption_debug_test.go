package main

import (
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"testing"
)

// TestKnownValuesFromJava tests decryption using the exact values generated by the Java test
// This helps debug production encryption/decryption issues
func TestKnownValuesFromJava(t *testing.T) {
	t.Log("=== Go Decryption Test with Known Java Values ===")
	
	// Values generated by the Java EncryptionDebugTestWithTestKeys.java
	plaintextToken := "test_fcm_token_for_debugging_123456789"
	aesKeyHex := "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
	ivHex := "00112233445566778899aabb"
	encryptedTokenBase64 := "ABEiM0RVZneImaq7AAACAH9OBoWmiLZW/JR8NzStE/OC7ModryKfzJfiaQpWTH6r67LXbs55kr9G6fkVT+V37E1zCpue4YRvzJPev09fJt7bG1+M8WjWxz6ZwkN2qEmfjoufOVlXvaufa204VUpdqTsknuX/jDtcmZJPJdU24Zi/cQJtJtC3NJJ/yEurHwdPACEoJbww4qF4wZtYTZ3bUBc4P2vf5sag+FbSdC1yFVrh5Q45PqBv0ykg+AwlComsrqsrrxp1hq1e1tbpPO0BySKHyTSmHmD7ewQHV7T4WK2JU6mnax8GxG+VaTkMWWd3GmFkZOIXmLFUYii8K+MHuT7hab9kPneFcONGwsnVxQ5tLq02Fhqq3Jn6zb+sndkfxIwrp8Oywt2ckXXLxjTGMtBCMnLd8kJM258awbaxmYXWYe76t22+EPwq2M2OD9YlE6K1Dp2VM3Fzz3NcUOBaYVinqUqubgXE7onYG4h251tSO5w+BTK+eoseDAFBLjHP187bY4/l+8EPBZX4+QQIcY2cPSG+cKGYJ5vQ/K9wp3Bkb/CXtEwCEjkZLMZ0vYHOYzefilgKQXgEo3pty5in1Zls9ZmCnzZrT5Iss6c6UuyV3Yg8V0MBpJKpdv0n8pNfm4pAXHyH0pXAzn/czKXQLXIcQRxBt2RD0G9EPjCmlBGaRE+6B5nIbmr5wFP+bsIxruODxxABKHM3FK93H+LdW1Zw7DF3CA7Q7eZ4l86BLIhMtd5chWIJc7ixUs5cUhhUCdsuYJI3"

	t.Logf("Expected plaintext token: %s", plaintextToken)
	t.Logf("Expected AES key (hex): %s", aesKeyHex)
	t.Logf("Expected IV (hex): %s", ivHex)
	t.Logf("Encrypted token (base64): %s", encryptedTokenBase64)

	// Load the test private key (we need to set up privateKey for decryption)
	originalPrivateKey := privateKey
	defer func() { privateKey = originalPrivateKey }()

	// Load test private key that we generated
	testPrivateKey, err := loadPrivateKey("test_private_key.pem")
	if err != nil {
		t.Fatalf("Failed to load test private key: %v", err)
	}
	privateKey = testPrivateKey

	// Attempt decryption
	decryptedToken, err := decryptHybridToken(encryptedTokenBase64)
	if err != nil {
		t.Fatalf("Decryption failed: %v", err)
	}

	t.Logf("Decrypted token: %s", decryptedToken)

	// Verify the decrypted token matches the expected plaintext
	if decryptedToken != plaintextToken {
		t.Errorf("Token mismatch: expected %q, got %q", plaintextToken, decryptedToken)
	} else {
		t.Logf("âœ“ Token decryption successful - matches expected plaintext")
	}

	// Test with a random token from the test keys
	randomEncryptedToken := "RNwAam3QKxx3W8BtAAACABfeFERIReaAtvMiML5Hj5YfjFqxMgII4IKnniqTHJWEfbyfgxYSg+/Z2B5Cq9uTQzdwKCychlT3fcVpIRVvKFLO5iREIWGzVNTlp8zJdeDCY1uDoP2twyf4wzT6I/GJq3RzKmAV3L/3DGWQ1ETyGEWNnvYQjTd/G+VOtDW5InBbUsQcxtmB8A4tvztJOtQaKnfOtWFBBBfDfz5XbMFNebJO9E2JoOz5uYqK7fCIRBecZ/AlKfkaRJS5jvJrSTGkcz7pg+8QyAGGek5Kbz9P59d8tnzl2p1uWZsrLnmNU4CwoxPpxAp79Y6/MXniaZXzln5iiC0qM+zdQoJ9OBwnbOjfiNaX9xB/rIT/GHygXbg9+Vnn/nB75P23HKHNUbiMQcqyxuseGOAdJsK+Jlih329OOrzlxHVQcS1VtVGxTM6dWE/Fq/LbgRBrhjJWsQmDhBI9mO/q8ilCL8Oo+1FczVUeXoIbI9x0VdtBI659f7t3UbNxzG2xu1kFGhumAvGdagPss/szpVeg4hU8gzAeC7t8onHTG5SkvsSjUPzg62MZWBYYFh+hoDOylAuer3Yu/Mpu3YlFAzx4PBnOTQ4KNqn8fxnpu3jCbes0qGHSOj4o21qVjHFb5aTXz+3udI2dBrfpcG/5RGoLX7hwfsZaJmg7bCO1g6zoSTLf/FiXPxiRoSoR0L00t0YPkDjLb3KDeZxzzUE4XeWYzet1t0azjP3AKsknXIu4JxE2obFyrDbCSC5aoMcWvCl7EFiZ8l90iTKXLhqlAnt1/VjURv8="
	t.Logf("\nAttempting to decrypt random token (should succeed with same key): %s", randomEncryptedToken[:50]+"...")

	randomDecrypted, err := decryptHybridToken(randomEncryptedToken)
	if err != nil {
		t.Logf("Random token decryption failed: %v", err)
	} else {
		t.Logf("Random token decrypted to: %s", randomDecrypted)
	}
}

// TestProductionCompatibility tests that the encryption format is compatible with production
func TestProductionCompatibility(t *testing.T) {
	t.Log("=== Production Compatibility Test ===")

	// Test various edge cases that might occur in production
	testCases := []struct {
		name        string
		token       string
		shouldFail  bool
		errorContains string
	}{
		{
			name:  "Normal FCM token",
			token: "dGVzdF90b2tlbl9mb3JfZmNt:APA91bEhY1abc123def456ghi789jkl012mno345pqr678stu901vwx234yz",
			shouldFail: false,
		},
		{
			name:  "Short token",
			token: "short_token",
			shouldFail: false,
		},
		{
			name:  "Long token",
			token: "very_long_token_" + string(make([]byte, 1000)),
			shouldFail: false,
		},
		{
			name:         "Extremely long token",
			token:        "extremely_long_token_" + string(make([]byte, 2500)),
			shouldFail:   true,
			errorContains: "too long",
		},
	}

	// Load test private key for testing
	originalPrivateKey := privateKey
	defer func() { privateKey = originalPrivateKey }()

	testPrivateKey, err := loadPrivateKey("test_private_key.pem")
	if err != nil {
		t.Fatalf("Failed to load test private key for testing: %v", err)
	}
	privateKey = testPrivateKey

	// Load test public key for encryption
	publicKeyPEM, err := readPublicKeyPEM("test_public_key.pem")
	if err != nil {
		t.Fatalf("Failed to load test public key for testing: %v", err)
	}

	// Parse public key
	publicKey, err := parsePublicKeyFromPEM(publicKeyPEM)
	if err != nil {
		t.Fatalf("Failed to parse public key: %v", err)
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Encrypt the token using the same method as the Android app
			encrypted, err := encryptTokenHybrid(tc.token, publicKey)
			if err != nil {
				t.Fatalf("Encryption failed: %v", err)
			}

			// Try to decrypt
			decrypted, err := decryptHybridToken(encrypted)

			if tc.shouldFail {
				if err == nil {
					t.Errorf("Expected failure for %s, but succeeded", tc.name)
				} else if tc.errorContains != "" && !contains(err.Error(), tc.errorContains) {
					t.Errorf("Expected error containing %q for %s, got: %v", tc.errorContains, tc.name, err)
				}
			} else {
				if err != nil {
					t.Errorf("Expected success for %s, got error: %v", tc.name, err)
				} else if decrypted != tc.token {
					t.Errorf("Token mismatch for %s: expected %q, got %q", tc.name, tc.token, decrypted)
				}
			}
		})
	}
}

// parsePublicKeyFromPEM parses a public key from PEM format
func parsePublicKeyFromPEM(publicKeyPEM string) (*rsa.PublicKey, error) {
	// This is a simplified version - in a real implementation you'd parse the PEM properly
	// For now, we'll use the existing loadPrivateKey pattern but adapt it for public keys
	block, _ := pem.Decode([]byte(publicKeyPEM))
	if block == nil {
		return nil, fmt.Errorf("failed to decode PEM block")
	}

	pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse public key: %v", err)
	}

	rsaPubKey, ok := pubKey.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("key is not an RSA public key")
	}

	return rsaPubKey, nil
}

// Helper function to check if a string contains a substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 || 
		(len(s) > len(substr) && (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr || 
			containsInner(s, substr))))
}

func containsInner(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
